<script type="text/html" id="notes-dialog">
<div>
    <!-- 笔记查看/编辑对话框 -->
<v-dialog v-model="show" max-width="600px" persistent scrollable content-class="notes-dialog-container">
  <v-card>
    <v-card-title class="headline">
      <div class="d-flex flex-1 align-center">
        <span>{{ noteData.title }}</span>
        <v-spacer></v-spacer>
        <v-btn icon @click="$emit('update:show',false)">
          <v-icon>fas fa-times</v-icon>
        </v-btn>
      </div>
    </v-card-title>
    <v-divider></v-divider>
    <v-progress-linear v-if="isLoading" value="15"></v-progress-linear>

    <v-card-text style="min-height: 300px; position: relative;">
      <div class="note-content markdown-body mt-3" v-html="renderedContent" @mouseover="handleReferenceIconHover" @mouseleave="handleReferenceIconLeave"></div>
    </v-card-text>
    <v-divider></v-divider>
    <v-card-actions>
      <span class="text-caption">创建于 {{ formatDate(noteData.createTime) }}</span>
      <v-spacer></v-spacer>
      <v-btn color="primary" text @click="$root.editNoteContent(noteData);$emit('update:show',false)">
        <v-icon left>fas fa-edit</v-icon>
        编辑
      </v-btn>

      <v-btn color="primary" text @click="copyContent">
        <v-icon left>fas fa-copy</v-icon>
        复制
      </v-btn>
    </v-card-actions>
  </v-card>
</v-dialog>

<!-- 引用浮层通过teleport/portal放置在body下 -->
<div class="reference-tooltip-container">
  <div v-show="showReferenceTooltip" class="reference-tooltip" :style="referenceTooltipStyle">
    <div class="reference-tooltip-header flex">
      <h3 class="flex-1">引用内容</h3>
      <v-btn x-small @click="$emit('update:show',false);$root.$refs.sourceSidebar.previewDocument(currentChunk.document_id)">
        <i class="fas fa-external-link-alt"></i>
        查看原文
    </v-btn>
    </div>
    <div v-if="isReferenceLoading" class="reference-loading">
      <i class="fas fa-spinner fa-spin"></i> 加载中...
    </div>
    <div v-else class="reference-content-wrapper">
      <div class="reference-tooltip-content" v-html="currentReferenceContent"></div>
    </div>
  </div>
</div>
</div>
</script>

<script>
  Vue.component('notes-dialog', {
    template: '#notes-dialog',
    props: {
      show: {
        type: Boolean,
        default: false
      },
      note: {
        type: String,
        default: {}
      }
    },
    data() {
      return {
        isLoading: false,
        noteData: {
          id: null,
          title: '',
          content: '',
          createTime: new Date().toISOString(),
          reference: null
        },
        showReferenceTooltip: false,
        referenceTooltipStyle: {},
        isReferenceLoading: false,
        currentReferenceContent: '',
        isMobile: window.innerWidth < 768,
        tooltipTimeout: null,
        currentChunk: {},
      }
    },
    computed: {
      renderedContent() {
        const content = this.noteData.content || '';
        return window.markdownUtils.renderMarkdown(content, this.noteData.reference);
      }
    },
    watch: {
      show(val) {
        if (val) {
          this.noteData = this.note;
          this.getNoteDetail();
        }
      }
    },
    methods: {
      async getNoteDetail() {
        if (!this.note.id) return;
        this.isLoading = true
        try {
          const response = await window.jianghuAxios({
            data: {
              appData: {
                pageId: 'allPage',
                actionId: 'getNoteDetail',
                where: {
                  id: this.note.id
                }
              }
            }
          });
          const rows = response.data.appData.resultData.rows || [];
          this.noteData = rows[0] || {};
        } catch (error) {
          console.error('获取笔记详情失败:', error);
          window.vtoast.error('获取笔记详情失败');
        } finally {

          this.isLoading = false
        }
      },

      copyContent() {
        navigator.clipboard.writeText(this.noteData.content)
          .then(() => {
            window.vtoast.success('内容已复制');
          })
          .catch(err => {
            console.error('复制失败:', err);
            window.vtoast.error('复制失败');
          });
      },

      formatDate(dateStr) {
        if (!dateStr) return '';
        const date = new Date(dateStr);
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');

        return `${year}-${month}-${day} ${hours}:${minutes}`;
      },

      handleReferenceIconHover(event) {
        const iconElement = event.target.closest('.reference-icon');
        if (!iconElement) return;

        const chunkIndex = iconElement.getAttribute('data-chunk-index');
        if (!chunkIndex) return;

        clearTimeout(this.tooltipTimeout);

        this.tooltipTimeout = setTimeout(() => {
          const rect = iconElement.getBoundingClientRect();
          
          // 计算弹窗位置，避免在移动端超出屏幕
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          
          // 设置弹窗宽度
          const tooltipWidth = this.isMobile ? Math.min(viewportWidth * 0.9, 400) : 400;
          
          // 计算左侧位置，确保不超出右侧屏幕
          let tooltipLeft = rect.left;
          if (tooltipLeft + tooltipWidth > viewportWidth) {
            tooltipLeft = Math.max(5, viewportWidth - tooltipWidth - 5);
          }
          
          // 计算顶部位置，如果底部空间不足，则显示在图标上方
          let tooltipTop = rect.bottom + 5;
          const estimatedHeight = 300; // 预估的弹窗高度
          if (tooltipTop + estimatedHeight > viewportHeight) {
            tooltipTop = Math.max(5, rect.top - estimatedHeight - 5);
          }

          this.referenceTooltipStyle = {
            position: 'fixed',
            top: `${tooltipTop}px`,
            left: `${tooltipLeft}px`,
            width: `${tooltipWidth}px`,
            maxHeight: `${Math.min(estimatedHeight, viewportHeight * 0.7)}px`,
            zIndex: 10000
          };

          this.isReferenceLoading = true;
          this.showReferenceTooltip = true;

          try {
            let chunks = [];
            if (this.noteData.reference) {
              if (typeof this.noteData.reference === 'string') {
                try {
                  const parsedReference = JSON.parse(this.noteData.reference);
                  chunks = parsedReference.chunks || [];
                } catch (e) {
                  console.error('解析引用数据失败:', e);
                }
              } else if (Array.isArray(this.noteData.reference)) {
                chunks = this.noteData.reference;
              } else if (this.noteData.reference.chunks) {
                chunks = this.noteData.reference.chunks;
              }
            }

            if (chunks && Array.isArray(chunks) &&
              chunkIndex >= 0 && chunkIndex < chunks.length &&
              chunks[chunkIndex]) {
              const chunk = chunks[chunkIndex];
              const rawContent = chunk.content || '';

              // 添加文档信息
              let contentWithDocInfo = rawContent;
              // contentWithDocInfo += '\n\n---\n\n';

              // 文档名称和链接处理
              const documentName = chunk.document_name || chunk.doc_name || '未知文档';
              const documentId = chunk.document_id || chunk.doc_id;

              // if (documentId) {
              //   contentWithDocInfo += `**参考资料：** <a href="#" target="_blank">${documentName}</a>`;
              // } else {
              //   contentWithDocInfo += `**参考资料：** ${documentName}`;
              // }

              marked.setOptions({
                gfm: true,
                headerIds: false,
                sanitize: false,
                mangle: false,
              });

              this.currentReferenceContent = marked.parse(contentWithDocInfo);
              this.currentChunk = chunk
            } else {
              this.currentReferenceContent = '<p>未找到引用内容</p>';
            }
          } catch (error) {
            console.error('处理引用内容时出错:', error);
            this.currentReferenceContent = '<p>加载引用内容失败</p>';
          }

          this.isReferenceLoading = false;

          this.$nextTick(() => {
            const tooltip = document.querySelector('.reference-tooltip-container .reference-tooltip');
            if (tooltip) {
              tooltip.addEventListener('mouseenter', this.handleTooltipEnter);
              tooltip.addEventListener('mouseleave', this.handleTooltipLeave);
            }
          });
        }, 100);
      },

      handleTooltipEnter() {
        clearTimeout(this.tooltipTimeout);
      },

      handleTooltipLeave() {
        clearTimeout(this.tooltipTimeout);
        this.tooltipTimeout = setTimeout(() => {
          this.showReferenceTooltip = false;
        }, 300);
      },

      handleReferenceIconLeave(event) {
        clearTimeout(this.tooltipTimeout);
        this.tooltipTimeout = setTimeout(() => {
          if (!this.isTooltipHovered()) {
            this.showReferenceTooltip = false;
          }
        }, 300);
      },

      isTooltipHovered() {
        const tooltip = document.querySelector('.reference-tooltip-container .reference-tooltip:hover');
        return tooltip !== null;
      }
    }
  });
</script>

<style>
</style>